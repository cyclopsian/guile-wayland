#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2020 Jason Francis <jason@cycles.network>
# SPDX-License-Identifier: GPL-3.0-or-later

import argparse, json, os, os.path, shlex, sys, subprocess

parser = argparse.ArgumentParser()
parser.add_argument('command', choices=['code', 'docs', 'docstrings'])
parser.add_argument('input')
parser.add_argument('output', default='-')
args = parser.parse_args()

srcfile = os.path.relpath(args.input, start='@builddir@')

with open(os.path.join('@builddir@', 'compile_commands.json'), 'r') as comcom:
    c_cmd = [f['command'] for f in json.load(comcom) if f['file'] == srcfile][0]

def filter_c_args(argv):
    i = 1
    while i < len(argv):
        arg = argv[i]
        if arg in ['-o', '-MF', '-MQ']:
            i += 1
        elif arg.startswith('-I'):
            if os.path.abspath(arg[2:]) or \
                    os.path.exists(os.path.join('@builddir', arg[2:])):
                yield arg
        elif arg not in ['-c', '-MD'] and not arg.startswith('-g'):
            yield arg
        i += 1

cpp_argv = shlex.split(c_cmd)
if cpp_argv[0] == 'ccache':
    cpp_argv = cpp_argv[1:]
cpp_args = list(filter_c_args(cpp_argv[1:])) + ['-E']

def run_cmd(argv, **kwargs):
    try:
        return subprocess.run(argv, **kwargs)
    except subprocess.CalledProcessError as e:
        print('Command failed:', shlex.join(e.cmd))
        sys.exit(e.returncode)

def snarf_docs(extraflags=[]):
    processed_src = run_cmd(
            [cpp_argv[0], '-DSCM_MAGIC_SNARF_DOCS'] + cpp_args,
            capture_output=True, check=True).stdout
    run_cmd(['@guile@', '--no-auto-compile',
            '@srcdir@/doc/snarf-docs.scm'] + extraflags + ['-o', args.output],
            input=processed_src, check=True)

if args.command == 'code':
    run_cmd(['@guile-snarf@', '-o', args.output] + cpp_args,
            env={**os.environ, 'CPP': cpp_argv[0]}, check=True)
elif args.command == 'docs':
    snarf_docs()
elif args.command == 'docstrings':
    snarf_docs(['--docstrings'])
